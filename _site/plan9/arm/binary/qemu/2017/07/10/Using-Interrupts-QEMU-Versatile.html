<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using Interrupts on the QEMU Versatile board</title>
  <meta name="description" content="Theory">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://qeedquan.github.io/plan9/arm/binary/qemu/2017/07/10/Using-Interrupts-QEMU-Versatile.html">
  <link rel="alternate" type="application/rss+xml" title="" href="http://qeedquan.github.io/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/"></a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Using Interrupts on the QEMU Versatile board</h1>
    <p class="post-meta"><time datetime="2017-07-10T00:00:00-04:00" itemprop="datePublished">Jul 10, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h3 id="theory">Theory</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Memory_management_unit">Memory Management Unit</a> (MMU) is a hardware unit that enables address translations such as going from virtual addresses to physical addresses.
Many major operating system today uses the MMU to provide memory protection and process isolation.</p>

<p>This tutorial is a continuation of the previous <a href="/plan9/arm/binary/2017/05/29/Plan9-Flat-ARM-Binaries.html">article</a> that will describe how to run the flat binary we have generated in an MMU context.
We based our code for setting up the MMU from the <a href="https://github.com/david50407/xv6-rpi">xv6-rpi</a> project. You can find the processor manual that describes
the registers that we write to <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/ddi0301h_arm1176jzfs_r0p7_trm.pdf">here</a>.</p>

<p>xv6-rpi builds the kernel image as an ELF file format that defines the load location to be placed at the expected
location. This is not a flat binary as it does contain an ELF file header but QEMU does know how to load an ELF file.
QEMU will place the image at the locations specified by the ELF file header.</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">kernel.elf is the kernel image generated by xv6-rpi when you do a make

$ readelf -e kernel.elf

ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x10000
  Start of program headers:          52 (bytes into file)
  Start of section headers:          710932 (bytes into file)
  Flags:                             0x5000200, Version5 EABI, soft-float ABI
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         16
  Section header string table index: 13

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .start_sec        PROGBITS        00010000 010000 009000 00 WAX  0   0  8
  [ 2] .text             PROGBITS        80020000 020000 008cf4 00  AX  0   0  4
  [ 3] .rodata           PROGBITS        80028cf4 028cf4 00080d 00   A  0   0  4
  [ 4] .data             PROGBITS        8002a000 02a000 0800c0 00  WA  0   0  4
  [ 5] .bss              NOBITS          800aa0c0 0aa0c0 00557c 00  WA  0   0  4
  [ 6] .ARM.attributes   ARM_ATTRIBUTES  00000000 0aa0c0 000027 00      0   0  1
  [ 7] .comment          PROGBITS        00000000 0aa0e7 000038 01  MS  0   0  1
  [ 8] .debug_frame      PROGBITS        00000000 0aa120 000040 00      0   0  4
  [ 9] .debug_line       PROGBITS        00000000 0aa160 000157 00      0   0  1
  [10] .debug_info       PROGBITS        00000000 0aa2b7 00020a 00      0   0  1
  [11] .debug_abbrev     PROGBITS        00000000 0aa4c1 00003c 00      0   0  1
  [12] .debug_aranges    PROGBITS        00000000 0aa500 000060 00      0   0  8
  [13] .shstrtab         STRTAB          00000000 0ad87a 00009a 00      0   0  1
  [14] .symtab           SYMTAB          00000000 0aa560 002880 10     15 434  4
  [15] .strtab           STRTAB          00000000 0acde0 000a9a 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x010000 0x00010000 0x00010000 0x09000 0x09000 RWE 0x10000
  LOAD           0x020000 0x80020000 0x00020000 0x8a0c0 0x8f63c RWE 0x10000

 Section to Segment mapping:
  Segment Sections...
   00     .start_sec 
   01     .text .rodata .data .bss </code></pre></figure>

<p>From the LOAD addresses specified in the program headers, the image will be loaded into physical memory at
0x010000 (.start_sec) and 0x020000 (.text) on startup. 0x010000 is the entry point
of the board on bootup and the code placed there will initialize the MMU and then it will
jump into the virtual address 0x80020000, which is the physical address 0x020000. This is known
as <a href="http://wiki.osdev.org/Identity_Paging">identity mapping</a> and an advantage of it is that the code region will not care if the MMU
is enabled or not.</p>

<p>The <a href="https://github.com/david50407/xv6-rpi/blob/master/src/kernel.ld">kernel.ld</a> script is what defines all of these locations, it is used by the GNU linker
to generate the location offsets while linking to make the ELF image.</p>

<p>This will be a problem for us using the Plan 9 toolchain, as the Plan 9 linker is not advanced enough
to specify multiple addresses to generate the code relative to.
The Plan 9 linker only allows us to specify one location that the code can be 
relative to using the -Taddr flag. The implication of this limitation is that if we want the simplest way without
jumping through hoops such as a secondary loader or addreess fixups is that we should set the address relative
to the startup address at 0x010000. But since we want the address relative to the virtual address space when
we enable the MMU, we need to set it to be relative to 0x80010000.</p>

<p>Another issue is that we will load using a flat binary, this means that QEMU will just copy all of the binary
into memory at the startup location at 0x010000 on startup in a contiguous manner, so it will not place anything at 0x020000
as it did for the xv6-rpi kernel image. We need to adjust the locations of the code and data placement so we can work
with the restriction of placing everything at 0x010000.</p>

<p>With these two limitations, we have to ask ourselves an important question before we continue.
How does this even work? If we specify the text segment at the virtual address 0x80010000, wouldnâ€™t the code generated
use this address then crash and burn due to being unmapped on bootup? To answer this we need to look at some assembly.</p>

<p>The source code we are about to disassemble is in <a href="https://github.com/qeedquan/qeedquan.github.io/blob/master/assets/plan9_flat_arm_mmu/entry.s">entry.s</a> and <a href="https://github.com/qeedquan/qeedquan.github.io/blob/master/assets/plan9_flat_arm_mmu/start.c">start.c</a>, review it to see what it is doing.</p>

<p>Here is the partial disassembly of the startup code generated by the Plan 9 toolchain:</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">$ aout2elf plan9.out
$ arm-none-eabi-objdump -D plan9.elf

plan9.elf:     file format elf32-littlearm


Disassembly of section .text:

80010000 &lt;_start&gt;:
80010000:       e3a01a02        mov     r1, #8192       ; 0x2000
80010004:       e3a02a09        mov     r2, #36864      ; 0x9000
80010008:       e3a03000        mov     r3, #0
8001000c:       e5813000        str     r3, [r1]
80010010:       e2811004        add     r1, r1, #4
80010014:       e1520001        cmp     r2, r1
80010018:       1afffffb        bne     8001000c &lt;_start+0xc&gt;
8001001c:       e3a010d3        mov     r1, #211        ; 0xd3
80010020:       e129f001        msr     CPSR_fc, r1
80010024:       e3a0da02        mov     sp, #8192       ; 0x2000
80010028:       eb00003c        bl      80010120 &lt;start&gt;
8001002c:       eafffffe        b       8001002c &lt;_start+0x2c&gt;

80010030 &lt;load_pgtbl&gt;:
80010030:       e59f34b0        ldr     r3, [pc, #1200] ; 800104e8 &lt;kmain+0x148&gt;
80010034:       ee033f10        mcr     15, 0, r3, cr3, cr0, {0}
80010038:       e3a03004        mov     r3, #4
8001003c:       ee023f50        mcr     15, 0, r3, cr2, cr0, {2}
80010040:       e1a03000        mov     r3, r0
80010044:       ee023f30        mcr     15, 0, r3, cr2, cr0, {1}
80010048:       e59d3008        ldr     r3, [sp, #8]
8001004c:       ee023f10        mcr     15, 0, r3, cr2, cr0, {0}
80010050:       ee113f10        mrc     15, 0, r3, cr1, cr0, {0}
80010054:       e59fb490        ldr     fp, [pc, #1168] ; 800104ec &lt;kmain+0x14c&gt;
80010058:       e183300b        orr     r3, r3, fp
8001005c:       ee013f10        mcr     15, 0, r3, cr1, cr0, {0}
80010060:       e3a03000        mov     r3, #0
80010064:       ee083f17        mcr     15, 0, r3, cr8, cr7, {0}
80010068:       e28ef000        add     pc, lr, #0

80010078 &lt;print0&gt;:
80010078:       e52de008        str     lr, [sp, #-8]!
8001007c:       e59f5474        ldr     r5, [pc, #1140] ; 800104f8 &lt;kmain+0x158&gt;
80010080:       e1a04000        mov     r4, r0
80010084:       e1d430d0        ldrsb   r3, [r4]
80010088:       e3530000        cmp     r3, #0
8001008c:       0a000004        beq     800100a4 &lt;print0+0x2c&gt;
80010090:       e4d42001        ldrb    r2, [r4], #1
80010094:       e5c52000        strb    r2, [r5]
80010098:       e1d430d0        ldrsb   r3, [r4]
8001009c:       e3530000        cmp     r3, #0
800100a0:       1afffffa        bne     80010090 &lt;print0+0x18&gt;
800100a4:       e49df008        ldr     pc, [sp], #8

800100a8 &lt;set_bootpgtbl&gt;:
800100a8:       e52de014        str     lr, [sp, #-20]! ; 0xffffffec
800100ac:       e59d601c        ldr     r6, [sp, #28]
800100b0:       e59d5020        ldr     r5, [sp, #32]
800100b4:       e3a03902        mov     r3, #32768      ; 0x8000
800100b8:       e58d300c        str     r3, [sp, #12]
800100bc:       e3a01901        mov     r1, #16384      ; 0x4000
800100c0:       e58d1008        str     r1, [sp, #8]
800100c4:       e1a04a20        lsr     r4, r0, #20
800100c8:       e1a07a26        lsr     r7, r6, #20
800100cc:       e1a08a25        lsr     r8, r5, #20
800100d0:       e3a06000        mov     r6, #0
800100d4:       e1560008        cmp     r6, r8
800100d8:       2a00000f        bcs     8001011c &lt;set_bootpgtbl+0x74&gt;
800100dc:       e1a03a07        lsl     r3, r7, #20
800100e0:       e59d1024        ldr     r1, [sp, #36]   ; 0x24
800100e4:       e3510000        cmp     r1, #0
800100e8:       059fb40c        ldreq   fp, [pc, #1036] ; 800104fc &lt;kmain+0x15c&gt;
800100ec:       0183500b        orreq   r5, r3, fp
800100f0:       159fb408        ldrne   fp, [pc, #1032] ; 80010500 &lt;kmain+0x160&gt;
800100f4:       1183500b        orrne   r5, r3, fp
800100f8:       e3540c01        cmp     r4, #256        ; 0x100
800100fc:       359d300c        ldrcc   r3, [sp, #12]
80010100:       37835104        strcc   r5, [r3, r4, lsl #2]
80010104:       259d3008        ldrcs   r3, [sp, #8]
80010108:       27835104        strcs   r5, [r3, r4, lsl #2]
8001010c:       e2844001        add     r4, r4, #1
80010110:       e2877001        add     r7, r7, #1
80010114:       e2866001        add     r6, r6, #1
80010118:       eaffffed        b       800100d4 &lt;set_bootpgtbl+0x2c&gt;
8001011c:       e49df014        ldr     pc, [sp], #20

80010120 &lt;start&gt;:
80010120:       e52de040        str     lr, [sp, #-64]! ; 0xffffffc0
80010124:       e3a01048        mov     r1, #72 ; 0x48
80010128:       e5cd1014        strb    r1, [sp, #20]
8001012c:       e3a02065        mov     r2, #101        ; 0x65
80010130:       e5cd2015        strb    r2, [sp, #21]
80010134:       e3a0306c        mov     r3, #108        ; 0x6c
80010138:       e5cd3016        strb    r3, [sp, #22]
8001013c:       e5cd3017        strb    r3, [sp, #23]
80010140:       e3a0206f        mov     r2, #111        ; 0x6f
80010144:       e5cd2018        strb    r2, [sp, #24]
80010148:       e3a03020        mov     r3, #32
8001014c:       e5cd3019        strb    r3, [sp, #25]
80010150:       e3a01066        mov     r1, #102        ; 0x66
80010154:       e5cd101a        strb    r1, [sp, #26]
80010158:       e3a02072        mov     r2, #114        ; 0x72
8001015c:       e5cd201b        strb    r2, [sp, #27]
80010160:       e3a0306f        mov     r3, #111        ; 0x6f
80010164:       e5cd301c        strb    r3, [sp, #28]
80010168:       e3a0106d        mov     r1, #109        ; 0x6d
8001016c:       e5cd101d        strb    r1, [sp, #29]
80010170:       e3a02020        mov     r2, #32
80010174:       e5cd201e        strb    r2, [sp, #30]
80010178:       e3a03073        mov     r3, #115        ; 0x73
8001017c:       e5cd301f        strb    r3, [sp, #31]
80010180:       e3a01074        mov     r1, #116        ; 0x74
80010184:       e5cd1020        strb    r1, [sp, #32]
80010188:       e3a02061        mov     r2, #97 ; 0x61
8001018c:       e5cd2021        strb    r2, [sp, #33]   ; 0x21
80010190:       e3a03072        mov     r3, #114        ; 0x72
80010194:       e5cd3022        strb    r3, [sp, #34]   ; 0x22
80010198:       e5cd1023        strb    r1, [sp, #35]   ; 0x23
8001019c:       e3a02028        mov     r2, #40 ; 0x28
800101a0:       e5cd2024        strb    r2, [sp, #36]   ; 0x24
800101a4:       e3a03029        mov     r3, #41 ; 0x29
800101a8:       e5cd3025        strb    r3, [sp, #37]   ; 0x25
800101ac:       e3a0102c        mov     r1, #44 ; 0x2c
800101b0:       e5cd1026        strb    r1, [sp, #38]   ; 0x26
800101b4:       e3a02020        mov     r2, #32
800101b8:       e5cd2027        strb    r2, [sp, #39]   ; 0x27
800101bc:       e3a03061        mov     r3, #97 ; 0x61
800101c0:       e5cd3028        strb    r3, [sp, #40]   ; 0x28
800101c4:       e3a01062        mov     r1, #98 ; 0x62
800101c8:       e5cd1029        strb    r1, [sp, #41]   ; 0x29
800101cc:       e3a0206f        mov     r2, #111        ; 0x6f
800101d0:       e5cd202a        strb    r2, [sp, #42]   ; 0x2a
800101d4:       e3a03075        mov     r3, #117        ; 0x75
800101d8:       e5cd302b        strb    r3, [sp, #43]   ; 0x2b
800101dc:       e3a01074        mov     r1, #116        ; 0x74
800101e0:       e5cd102c        strb    r1, [sp, #44]   ; 0x2c
800101e4:       e3a02020        mov     r2, #32
800101e8:       e5cd202d        strb    r2, [sp, #45]   ; 0x2d
800101ec:       e5cd102e        strb    r1, [sp, #46]   ; 0x2e
800101f0:       e3a0106f        mov     r1, #111        ; 0x6f
800101f4:       e5cd102f        strb    r1, [sp, #47]   ; 0x2f
800101f8:       e5cd2030        strb    r2, [sp, #48]   ; 0x30
800101fc:       e3a03073        mov     r3, #115        ; 0x73
80010200:       e5cd3031        strb    r3, [sp, #49]   ; 0x31
80010204:       e3a01065        mov     r1, #101        ; 0x65
80010208:       e5cd1032        strb    r1, [sp, #50]   ; 0x32
8001020c:       e3a02074        mov     r2, #116        ; 0x74
80010210:       e5cd2033        strb    r2, [sp, #51]   ; 0x33
80010214:       e3a03075        mov     r3, #117        ; 0x75
80010218:       e5cd3034        strb    r3, [sp, #52]   ; 0x34
8001021c:       e3a01070        mov     r1, #112        ; 0x70
80010220:       e5cd1035        strb    r1, [sp, #53]   ; 0x35
80010224:       e3a02020        mov     r2, #32
80010228:       e5cd2036        strb    r2, [sp, #54]   ; 0x36
8001022c:       e3a03074        mov     r3, #116        ; 0x74
80010230:       e5cd3037        strb    r3, [sp, #55]   ; 0x37
80010234:       e3a01068        mov     r1, #104        ; 0x68
80010238:       e5cd1038        strb    r1, [sp, #56]   ; 0x38
8001023c:       e3a02065        mov     r2, #101        ; 0x65
80010240:       e5cd2039        strb    r2, [sp, #57]   ; 0x39
80010244:       e3a03020        mov     r3, #32
80010248:       e5cd303a        strb    r3, [sp, #58]   ; 0x3a
8001024c:       e3a0104d        mov     r1, #77 ; 0x4d
80010250:       e5cd103b        strb    r1, [sp, #59]   ; 0x3b
80010254:       e5cd103c        strb    r1, [sp, #60]   ; 0x3c
80010258:       e3a03055        mov     r3, #85 ; 0x55
8001025c:       e5cd303d        strb    r3, [sp, #61]   ; 0x3d
80010260:       e3a0100a        mov     r1, #10
80010264:       e5cd103e        strb    r1, [sp, #62]   ; 0x3e
80010268:       e3a02000        mov     r2, #0
8001026c:       e5cd203f        strb    r2, [sp, #63]   ; 0x3f
80010270:       e28d0014        add     r0, sp, #20
80010274:       ebffff7f        bl      80010078 &lt;print0&gt;
80010278:       e3a00000        mov     r0, #0
8001027c:       e58d0008        str     r0, [sp, #8]
80010280:       e3a01601        mov     r1, #1048576    ; 0x100000
80010284:       e58d100c        str     r1, [sp, #12]
80010288:       e58d0010        str     r0, [sp, #16]
8001028c:       ebffff85        bl      800100a8 &lt;set_bootpgtbl&gt;
80010290:       e3a00102        mov     r0, #-2147483648        ; 0x80000000
80010294:       e3a03000        mov     r3, #0
80010298:       e58d3008        str     r3, [sp, #8]
8001029c:       e3a01601        mov     r1, #1048576    ; 0x100000
800102a0:       e58d100c        str     r1, [sp, #12]
800102a4:       e58d3010        str     r3, [sp, #16]
800102a8:       ebffff7e        bl      800100a8 &lt;set_bootpgtbl&gt;
800102ac:       e59f0250        ldr     r0, [pc, #592]  ; 80010504 &lt;kmain+0x164&gt;
800102b0:       e3a03000        mov     r3, #0
800102b4:       e58d3008        str     r3, [sp, #8]
800102b8:       e3a01601        mov     r1, #1048576    ; 0x100000
800102bc:       e58d100c        str     r1, [sp, #12]
800102c0:       e58d3010        str     r3, [sp, #16]
800102c4:       ebffff77        bl      800100a8 &lt;set_bootpgtbl&gt;
800102c8:       e3a00209        mov     r0, #-1879048192        ; 0x90000000
800102cc:       e3a03201        mov     r3, #268435456  ; 0x10000000
800102d0:       e58d3008        str     r3, [sp, #8]
800102d4:       e3a01302        mov     r1, #134217728  ; 0x8000000
800102d8:       e58d100c        str     r1, [sp, #12]
800102dc:       e3a02001        mov     r2, #1
800102e0:       e58d2010        str     r2, [sp, #16]
800102e4:       ebffff6f        bl      800100a8 &lt;set_bootpgtbl&gt;
800102e8:       e3a00901        mov     r0, #16384      ; 0x4000
800102ec:       e3a03902        mov     r3, #32768      ; 0x8000
800102f0:       e58d3008        str     r3, [sp, #8]
800102f4:       ebffff4d        bl      80010030 &lt;load_pgtbl&gt;
800102f8:       ebffff5b        bl      8001006c &lt;jump_stack&gt;
800102fc:       e49df040        ldr     pc, [sp], #64   ; 0x40</code></pre></figure>

<p>It seems that the toolchain is placing the code at 0x80010000 on startup but take a deeper look at the instructions.
All these instructions do not depend on where they are in memory. One glaring instruction is the BL instruction for
calling functions, does that not use absolute locations? It turns out not to be the case, the BL instruction is jumping relative to its location;
objdump calculated that address for us and printed it out like an absolute location but it is not really not (refer to the ARM manual).</p>

<p>The Plan 9 toolchain does not generate code that needs the exact address for simple statements,
function calls, loops, and local variable access. But it does generate code that does
depend on the location for constant string lookups and global variable accesses. It will look up the data address 
and calculate the relative offset to that; it encodes the offset in the binary for those. 
This means that we cannot use global variables or pointer to constant strings before we enable the MMU and 
work in the virtual address space at 0x80010000.</p>

<p>Even if we canâ€™t use global variables or string pointers from the code, we can certainly use them if we know
the exact memory location of where they are in memory. This means when we need access to a global variable
or string constant before we enable the MMU, we just need to specify an absolute physical location to it.</p>

<p>This ends the coverage of the basic theory on how this will work, let us see how this plays out in the code.</p>

<h3 id="practice">Practice</h3>

<p><a href="https://github.com/david50407/xv6-rpi/blob/master/src/kernel.ld">kernel.ld</a> defines various symbols for use in the code that we need to define in the Plan 9 code.
Here are the symbols we are going to need:</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">These are all in physical memory

edata_entry:   The start of the address of all the data structures we need to enable the MMU
svc_stktop:    The top of the stack pointer
_kernel_pgtbl: The location of the kernel page table
_user_pgtbl:   The location of the user page table</code></pre></figure>

<p>We use nm on the kernel.elf to see where it places its symbol in memory. Then we will define
it in a header file directly</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">$ nm kernel.elf | grep 'edata_entry\|svc_stktop\|_kernel_pgtbl\|_user_pgtbl'

00010548 T edata_entry
00014000 T _kernel_pgtbl
00012000 T svc_stktop
00018000 T _user_pgtbl</code></pre></figure>

<p>edata_entry does not seem to end at a nice address, so we will just round it to a nice address for our code.
We will also need to adjust these memory locations and place it before the Plan 9 .text to make sure our binary image
does override these locations if the binary ever grew big enough. (The GNU linker does not do this because it can calculate
it on the fly and the addresses we see above is just one instance of the computation)</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// memlayout.h
</span>
<span class="c1">// first kernel address
</span><span class="cp">#define KERNBASE 0x80000000
</span>
<span class="c1">// map the first 1 MB low memory containing kernel code.
</span><span class="cp">#define INIT_KERNMAP 0x100000
</span>
<span class="c1">// start of kernel data structures we need
</span><span class="cp">#define edata_entry 0x2000
</span>
<span class="c1">// stack for bootstrapping
</span><span class="cp">#define svc_stktop 0x2000
</span>
<span class="c1">// kernel page table address
</span><span class="cp">#define _kernel_pgtbl 0x4000
</span>
<span class="c1">// user page table address
</span><span class="cp">#define _user_pgtbl 0x8000
</span>
<span class="c1">// end of kernel data structures we need
</span><span class="cp">#define end_entry 0x9000
</span>
<span class="cp">#define P2V(a) ((a) + KERNBASE)</span></code></pre></figure>

<p>We just took the constants and subtracted it by 0x10000 and rounded the edata_entry to where svc_stktop is, we donâ€™t care 
about the other locations so we donâ€™t need to care about allocating memory for those as they did. They are striving for a complete kernel and we are just trying to show a demo of using the MMU.</p>

<p>We port over entry.S, start.c, and main.c to Plan 9. Due to the fact that the Plan 9 compiler does not support inline assembly,
any code that uses it in xv6-rpi will have to be done in the assembly file such as the load_pgtbl() function.</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">#include "memlayout.h"
#include "arm.h"
#include "mmu.h"

TEXT _start(SB), 1, $-4
	// clear the memory for data structures we need
	MOVW    $(edata_entry), R1
	MOVW    $(end_entry), R2
	MOVW    $0, R3
_zero:
	MOVW    R3, (R1)
	ADD     $4, R1
	CMP     R1, R2
	BNE     _zero

	// set supervisor mode, no interrupts
	MOVW    $(SVC_MODE|NO_INT), R1
	MOVW    R1, CPSR

	// set the stack pointer to jump into C
	MOVW    $(svc_stktop), SP
	BL      start(SB)

	// loop forever
	B       0(PC)

// loads the page tables for kernel and user
// void load_pgtbl(u32 *kernel_pgtbl, u32 *user_pgtbl)
// R0    - kernel_pgtbl
// SP[8] - user_pgtbl
TEXT load_pgtbl(SB), 1, $-4
	// set the domain access control; all domains are checked for permission
	MOVW    $0x55555555, R3
	MCR     15, 0, R3, C(3), C(0), 0

	// set the page table base registers; we use two tables:
	// TTBR0 for user space and TTBR1 for kernel space
	MOVW    $(32-UADDR_BITS), R3
	MCR     15, 0, R3, C(2), C(0), 2

	// load the kernel page table
	MOVW    R0, R3
	MCR     15, 0, R3, C(2), C(0), 1

	// load the user page table
	MOVW    8(SP), R3
	MCR     15, 0, R3, C(2), C(0), 0

	// enable MMU, cache, write buffer, high vector tbl,
	// disable subpage
	MRC     15, 0, R3, C(1), C(0), 0
	ORR     $0x80300D, R3
	MCR     15, 0, R3, C(1), C(0), 0

	// flush the TLB
	MOVW    $0, R3
	MCR     15, 0, R3, C(8), C(7), 0

	RET

// once we get here, we have enabled the MMU and setup the page tables
// when the kernel booted up, it was in user address space, but
// now we can use the kernel address space now for the kernel
TEXT jump_stack(SB), 1, $-4
	// R12 defined by the linker is relative to the kernel address
	// so we couldn't use it until now
	MOVW    $setR12(SB), R12
	
	// setup stack pointer to be in kernel virtual address now
	ADD     $(KERNBASE), SP

	// jump to the address of main, main is in the kernel address range
	// we couldn't load this before the MMU is setup properly
	MOVW    $kmain(SB), PC</code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* start.c */</span>

<span class="cp">#include "types.h"
#include "memlayout.h"
#include "arm.h"
#include "mmu.h"
</span>
<span class="kt">void</span> <span class="n">jump_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">load_pgtbl</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">set_me</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">print0</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">UART0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// setup the boot page table: dev_mem whether it is device memory
</span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">set_bootpgtbl</span><span class="p">(</span><span class="n">u32</span> <span class="n">virt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phy</span><span class="p">,</span> <span class="n">uint</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev_mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pde</span><span class="p">,</span> <span class="o">*</span><span class="n">user_pgtbl</span><span class="p">,</span> <span class="o">*</span><span class="n">kernel_pgtbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">user_pgtbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">_user_pgtbl</span><span class="p">;</span>
	<span class="n">kernel_pgtbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">_kernel_pgtbl</span><span class="p">;</span>

	<span class="c1">// convert all the parameters to indexes
</span>	<span class="n">virt</span> <span class="o">&gt;&gt;=</span> <span class="n">PDE_SHIFT</span><span class="p">;</span>
	<span class="n">phy</span> <span class="o">&gt;&gt;=</span> <span class="n">PDE_SHIFT</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">&gt;&gt;=</span> <span class="n">PDE_SHIFT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pde</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy</span> <span class="o">&lt;&lt;</span> <span class="n">PDE_SHIFT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_mem</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// normal memory, make it kernel-only, cachable, bufferable
</span>			<span class="n">pde</span> <span class="o">|=</span> <span class="p">(</span><span class="n">AP_KO</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="n">PE_CACHE</span> <span class="o">|</span> <span class="n">PE_BUF</span> <span class="o">|</span> <span class="n">KPDE_TYPE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// device memory, make it non-cachable and non-bufferable
</span>			<span class="n">pde</span> <span class="o">|=</span> <span class="p">(</span><span class="n">AP_KO</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="n">KPDE_TYPE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// use different page table for user/kernel space
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">virt</span> <span class="o">&lt;</span> <span class="n">NUM_UPDE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">user_pgtbl</span><span class="p">[</span><span class="n">virt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pde</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kernel_pgtbl</span><span class="p">[</span><span class="n">virt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pde</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">virt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// print out a message to let us know that we made it here
</span>	<span class="c1">// we can't use char* because the string generated will not
</span>	<span class="c1">// be accessible yet since the R12 has not been setup yet
</span>	<span class="c1">// and we haven't relocated to the kernel address yet
</span>	<span class="c1">// we put the string on the stack here so we can print it
</span>	<span class="kt">char</span> <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello from start(), about to setup the MMU</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="n">print0</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="c1">// double map the memory required for paging
</span>	<span class="c1">// we do not map all the physical memory
</span>	<span class="n">set_bootpgtbl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INIT_KERNMAP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_bootpgtbl</span><span class="p">(</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INIT_KERNMAP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="c1">// map the vector table
</span>	<span class="n">set_bootpgtbl</span><span class="p">(</span><span class="n">VEC_TBL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PDE_SHIFT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="c1">// map the devices so we can use the devices when we we enable the MMU
</span>	<span class="n">set_bootpgtbl</span><span class="p">(</span><span class="n">KERNBASE</span> <span class="o">+</span> <span class="n">DEVBASE</span><span class="p">,</span> <span class="n">DEVBASE</span><span class="p">,</span> <span class="n">DEV_MEM_SZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="c1">// load the page table
</span>	<span class="n">load_pgtbl</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">_kernel_pgtbl</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">_user_pgtbl</span><span class="p">);</span>

	<span class="c1">// we have set up the MMU now, jump to the kernel address space
</span>	<span class="n">jump_stack</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>We start in _start on bootup and we clear out the memory for the data structures we will setup for the MMU and stack.
Then we jump to start() in C to make it easier to setup the data structure for the MMU. 
start() will setup the pages for <a href="http://wiki.osdev.org/Identity_Paging">identity mapping</a> using set_bootpgtbl() and then call load_pgtbl() to tell the CPU
of where the page tables are and enable the MMU. We then call jump_stack() to switch over to the virtual address
space by setting up the stack pointer and program counter to be inside the virtual address space. We then call kmain()
and inside kmain(), test various constructs such as global variable access, string constants, and pointer dereferencing.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* kmain.c */</span>

<span class="cp">#include "types.h"
#include "arm.h"
#include "memlayout.h"
</span>
<span class="cp">#define nelem(x) (sizeof(x) / sizeof(x[0]))
</span>
<span class="kt">void</span>
<span class="nf">putc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">P2V</span><span class="p">(</span><span class="n">UART0</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">putln</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
		<span class="n">putc</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
	<span class="n">putc</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">puthex</span><span class="p">(</span><span class="n">uint</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hex</span> <span class="o">=</span> <span class="s">"0123456789ABCDEF"</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">putc</span><span class="p">(</span><span class="n">hex</span><span class="p">[(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">]);</span>
	<span class="n">putc</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// test if we can access global variables now
</span><span class="k">static</span> <span class="kt">char</span> <span class="n">bar</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"bar"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tab</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"tab1"</span><span class="p">,</span>
    <span class="s">"tab2"</span><span class="p">,</span>
    <span class="s">"tab3"</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pidx</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_me</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">test_struct</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">t1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">t2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t3</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">"xxx"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"aaa"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"bbb"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"ccc"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"ddd"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"eee"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"fff"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"ggg"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"hhh"</span><span class="p">,</span> <span class="s">"yyy"</span><span class="p">,</span> <span class="mh">0x110</span><span class="p">},</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">kmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">putln</span><span class="p">(</span><span class="s">"we are in kmain(), with the MMU enabled!"</span><span class="p">);</span>
	<span class="n">putln</span><span class="p">(</span><span class="s">"running some tests to see if we can access strings and variables"</span><span class="p">);</span>
	<span class="n">putln</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
	<span class="n">putln</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">nelem</span><span class="p">(</span><span class="n">tab</span><span class="p">);</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">putln</span><span class="p">(</span><span class="n">tab</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
	<span class="n">puthex</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="o">&amp;</span><span class="n">idx</span><span class="p">);</span>

	<span class="n">pidx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idx</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
	<span class="n">puthex</span><span class="p">(</span><span class="o">*</span><span class="n">pidx</span><span class="p">);</span>

	<span class="n">set_me</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span>
	<span class="n">puthex</span><span class="p">(</span><span class="n">set_me</span><span class="p">);</span>
	<span class="n">puthex</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="o">&amp;</span><span class="n">set_me</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">set_me</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">set_me</span> <span class="o">&lt;</span> <span class="n">nelem</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span> <span class="n">set_me</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">putln</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">set_me</span><span class="p">].</span><span class="n">t1</span><span class="p">);</span>
		<span class="n">putln</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">set_me</span><span class="p">].</span><span class="n">t2</span><span class="p">);</span>
		<span class="n">puthex</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">set_me</span><span class="p">].</span><span class="n">t3</span><span class="p">);</span>
		<span class="n">puthex</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">[</span><span class="n">set_me</span><span class="p">].</span><span class="n">t1</span><span class="p">);</span>
		<span class="n">puthex</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">[</span><span class="n">set_me</span><span class="p">].</span><span class="n">t2</span><span class="p">);</span>
		<span class="n">puthex</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">[</span><span class="n">set_me</span><span class="p">].</span><span class="n">t3</span><span class="p">);</span>
		<span class="n">putc</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// we did not setup a return when we got to here so we don't want
</span>	<span class="c1">// to jump into space on return, just loop forever
</span>	<span class="k">for</span> <span class="p">(;;)</span>
		<span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>If all went well, we should be in virtual address space executing code. Here is the QEMU output:</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel plan9
Hello from start(), about to setup the MMU
we are in kmain(), with the MMU enabled!
running some tests to see if we can access strings and variables
bar
foo
tab1
tab2
tab3
80011008
0000001E
DEADBEEF
80011000
xxx
yyy
00000030
80011020
80011024
80011028

aaa
yyy
00000040
8001102C
80011030
80011034

bbb
yyy
00000050
80011038
8001103C
80011040

ccc
yyy
00000060
80011044
80011048
8001104C

ddd
yyy
00000070
80011050
80011054
80011058

eee
yyy
00000080
8001105C
80011060
80011064

fff
yyy
00000090
80011068
8001106C
80011070

ggg
yyy
00000100
80011074
80011078
8001107C

hhh
yyy
00000110
80011080
80011084
80011088</code></pre></figure>

<p>You can get the code to the demo at this <a href="https://github.com/qeedquan/qeedquan.github.io/tree/master/assets/plan9_flat_arm_mmu">url</a>.</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/qeedquan"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">qeedquan</span></a>

          </li>
          

          
		  
          
          <li>
            <a href="https://www.linkedin.com/in/quan-tran-15a72831"><span class="icon icon--linkedin"><svg viewBox="0 0 512 512"><path fill="#ffb577" d="M186.4 142.4c0 19-15.3 34.5-34.2 34.5 -18.9 0-34.2-15.4-34.2-34.5 0-19 15.3-34.5 34.2-34.5C171.1 107.9 186.4 123.4 186.4 142.4zM181.4 201.3h-57.8V388.1h57.8V201.3zM273.8 201.3h-55.4V388.1h55.4c0 0 0-69.3 0-98 0-26.3 12.1-41.9 35.2-41.9 21.3 0 31.5 15 31.5 41.9 0 26.9 0 98 0 98h57.5c0 0 0-68.2 0-118.3 0-50-28.3-74.2-68-74.2 -39.6 0-56.3 30.9-56.3 30.9v-25.2H273.8z"/></svg>
</span><span class="username">qeedquan</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
